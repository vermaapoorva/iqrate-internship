/**
 * PipedriveAPIV1Lib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');
const _oAuthManager = require('../OAuthManager');

class OrganizationsController {
    /**
     * Marks multiple organizations as deleted.
     *
     * @param {string} ids Comma-separated IDs that will be deleted
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteMultipleOrganizationsInBulk(ids, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/organizations';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            ids,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.deleteMultipleOrganizationsInBulkAction(
                _queryUrl,
                _callback,
                ids);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.deleteMultipleOrganizationsInBulkAction(
                _queryUrl,
                _callback,
                ids),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteMultipleOrganizationsInBulkAction(_queryUrl, _callback, ids) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns all organizations
     *
     * @param  {array}  input    Array with all options for search
     * @param {int} input['userId'] (optional) If supplied, only organizations owned by the given
     * user will be returned.
     * @param {int} input['filterId'] (optional) ID of the filter to use
     * @param {string} input['firstChar'] (optional) If supplied, only organizations whose name
     * starts with the specified letter will be returned (case
     * insensitive).
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys).
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getAllOrganizations(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/organizations';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            user_id: input.userId,
            filter_id: input.filterId,
            first_char: input.firstChar,
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            sort: input.sort,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.getAllOrganizationsAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.getAllOrganizationsAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getAllOrganizationsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a new organization. Note that you can supply additional custom fields along with the
     * request that are not described here. These custom fields are different for each Pipedrive
     * account and can be recognized by long hashes as keys. To determine which custom fields
     * exists, fetch the organizationFields and look for 'key' values. For more information on
     * how to add an organization, see <a href="https://pipedrive.readme.io/docs/adding-an-
     * organization" target="_blank" rel="noopener noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {string} input['contentType'] (optional) TODO: type description here
     * @param {object} input['body'] (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/organizations';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.addAnOrganizationAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.addAnOrganizationAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': input.contentType,
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(input.body),
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Searches all organizations by their name.
     *
     * @param  {array}  input    Array with all options for search
     * @param {string} input['term'] Search term to look for
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static findOrganizationsByName(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/organizations/find';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            term: input.term,
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.findOrganizationsByNameAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.findOrganizationsByNameAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static findOrganizationsByNameAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Marks an organization as deleted.
     *
     * @param {double} id ID of the organization
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteAnOrganization(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.deleteAnOrganizationAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.deleteAnOrganizationAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteAnOrganizationAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns details of an organization. Note that this also returns some additional fields
     * which are not present when asking for all organizations. Also note that custom fields
     * appear as long hashes in the resulting data. These hashes can be mapped against the 'key'
     * value of organizationFields.
     *
     * @param {double} id ID of the organization
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDetailsOfAnOrganization(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.getDetailsOfAnOrganizationAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.getDetailsOfAnOrganizationAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getDetailsOfAnOrganizationAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Updates the properties of an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {string} input['name'] (optional) Organization name
     * @param {int} input['ownerId'] (optional) ID of the user who will be marked as the owner of
     * this organization. When omitted, the authorized user ID will
     * be used.
     * @param {VisibleToEnum} input['visibleTo'] (optional) Visibility of the organization. If
     * omitted, visibility will be set to the default
     * visibility setting of this item type for the
     * authorized user.<dl class=\"fields-
     * list\"><dt>1</dt><dd>Owner &amp; followers
     * (private)</dd><dt>3</dt><dd>Entire company
     * (shared)</dd></dl>
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.updateAnOrganizationAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.updateAnOrganizationAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });

        // prepare form data
        const _form = {
            name: input.name,
            owner_id: input.ownerId,
            visible_to: (input.visibleTo !== null) ? input.visibleTo : null,
        };

        input.name = undefined;
        input.ownerId = undefined;
        input.visibleTo = undefined;

        const _formWithDynamicFields = { ...input, ..._form};

        // remove null values
        _apiHelper.cleanObject(_formWithDynamicFields);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _formWithDynamicFields,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists activities associated with an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['done'] (optional) Whether the activity is done or not. 0 =
     * Not done, 1 = Done. If omitted returns both Done
     * and Not done activities.
     * @param {string} input['exclude'] (optional) A comma-separated string of activity IDs to
     * exclude from result
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listActivitiesAssociatedWithAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/activities';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            done: (input.done !== null) ? input.done : null,
            exclude: input.exclude,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listActivitiesAssociatedWithAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listActivitiesAssociatedWithAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listActivitiesAssociatedWithAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists deals associated with an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {Status2Enum} input['status'] (optional) Only fetch deals with specific status. If
     * omitted, all not deleted deals are fetched.
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys).
     * @param {NumberBooleanEnum} input['onlyPrimaryAssociation'] (optional) If set, only deals
     * that are directly associated to
     * the organization are fetched. If
     * not set (default), all deals are
     * fetched that are either directly
     * or indirectly related to the
     * organization. Indirect relations
     * include relations through custom,
     * organization-type fields and
     * through persons of the given
     * organization.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listDealsAssociatedWithAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/deals';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            status: (input.status !== null) ? input.status : 'all_not_deleted',
            sort: input.sort,
            only_primary_association: (input.onlyPrimaryAssociation !== null) ? input.onlyPrimaryAssociation : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listDealsAssociatedWithAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listDealsAssociatedWithAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listDealsAssociatedWithAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists files associated with an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['includeDeletedFiles'] (optional) When enabled, the list of
     * files will also include deleted
     * files. Please note that trying to
     * download these files will not work.
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys). Supported fields: id,
     * user_id, deal_id, person_id, org_id, product_id, add_time,
     * update_time, file_name, file_type, file_size, comment.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listFilesAttachedToAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/files';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            include_deleted_files: (input.includeDeletedFiles !== null) ? input.includeDeletedFiles : null,
            sort: input.sort,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listFilesAttachedToAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listFilesAttachedToAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listFilesAttachedToAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists updates about an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listUpdatesAboutAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/flow';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listUpdatesAboutAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listUpdatesAboutAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listUpdatesAboutAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists the followers of an organization.
     *
     * @param {double} id ID of the organization
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listFollowersOfAnOrganization(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/followers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listFollowersOfAnOrganizationAction(
                _queryUrl,
                _callback);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listFollowersOfAnOrganizationAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listFollowersOfAnOrganizationAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a follower to an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {int} input['userId'] ID of the user
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addAFollowerToAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/followers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.addAFollowerToAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.addAFollowerToAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addAFollowerToAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            user_id: input.userId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Deletes a follower from an organization. You can retrieve the follower_id from the <a
     * href="https://developers.pipedrive.com/docs/api/v1/#!
     * /Organizations/get_organizations_id_followers">List followers of an organization</a>
     * endpoint.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {double} input['followerId'] ID of the follower
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteAFollowerFromAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/followers/{follower_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
            follower_id: input.followerId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.deleteAFollowerFromAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.deleteAFollowerFromAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteAFollowerFromAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists mail messages associated with an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listMailMessagesAssociatedWithAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/mailMessages';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listMailMessagesAssociatedWithAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listMailMessagesAssociatedWithAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listMailMessagesAssociatedWithAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Merges an organization with another organization. For more information on how to merge two
     * organizations, see <a href="https://pipedrive.readme.io/docs/merging-two-organizations"
     * target="_blank" rel="noopener noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {int} input['mergeWithId'] ID of the organization that the organization will be
     * merged with
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateMergeTwoOrganizations(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/merge';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.updateMergeTwoOrganizationsAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.updateMergeTwoOrganizationsAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateMergeTwoOrganizationsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            merge_with_id: input.mergeWithId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * List users permitted to access an organization
     *
     * @param {double} id ID of the organization
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listPermittedUsers(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/permittedUsers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listPermittedUsersAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listPermittedUsersAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listPermittedUsersAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists persons associated with an organization.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the organization
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listPersonsOfAnOrganization(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/organizations/{id}/persons';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return OrganizationsController.listPersonsOfAnOrganizationAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => OrganizationsController.listPersonsOfAnOrganizationAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listPersonsOfAnOrganizationAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
}
module.exports = OrganizationsController;

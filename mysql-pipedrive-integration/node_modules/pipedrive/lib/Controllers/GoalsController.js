/**
 * PipedriveAPIV1Lib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');
const _oAuthManager = require('../OAuthManager');

class GoalsController {
    /**
     * Adds a new goal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {string} input['contentType'] (optional) TODO: type description here
     * @param {object} input['body'] (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addANewGoal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/goals';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return GoalsController.addANewGoalAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => GoalsController.addANewGoalAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addANewGoalAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': input.contentType,
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(input.body),
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns data about goals based on criteria. For searching, append
     * `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-
     * level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue`
     * should be the value you are looking for on that field. Additionally,
     * `is_active=<true|false>` can be provided to search for only active/inactive goals. When
     * providing `period.start`, `period.end` must also be provided and vice versa.
     *
     * @param  {array}  input    Array with all options for search
     * @param {TypeNameEnum} input['typeName'] (optional) Type of the goal. If provided, everyone's
     * goals will be returned.
     * @param {string} input['title'] (optional) Title of the goal.
     * @param {bool} input['isActive'] (optional) Whether goal is active or not.
     * @param {int} input['assigneeId'] (optional) ID of the user who's goal to fetch. When omitted,
     * only your goals will be returned.
     * @param {AssigneeTypeEnum} input['assigneeType'] (optional) Type of the goal's assignee. If
     * provided, everyone's goals will be returned.
     * @param {double} input['expectedOutcomeTarget'] (optional) Numeric value of the outcome. If
     * provided, everyone's goals will be returned.
     * @param {ExpectedOutcomeTrackingMetricEnum} input['expectedOutcomeTrackingMetric'] (optional)
     * Tracking
     * metric of
     * the
     * expected
     * outcome of
     * the goal.
     * If
     * provided,
     * everyone's
     * goals will
     * be
     * returned.
     * @param {int} input['expectedOutcomeCurrencyId'] (optional) Numeric ID of the goal's currency.
     * Only applicable to goals with
     * `expected_outcome.tracking_metric` with
     * value `sum`. If provided, everyone's goals
     * will be returned.
     * @param {int} input['typeParamsPipelineId'] (optional) ID of the pipeline or `null` for all
     * pipelines. If provided, everyone's goals will be
     * returned.
     * @param {int} input['typeParamsStageId'] (optional) ID of the stage. Applicable to only
     * `deals_progressed` type of goals. If provided,
     * everyone's goals will be returned.
     * @param {int} input['typeParamsActivityTypeId'] (optional) ID of the activity type.
     * Applicable to only `activities_completed` or
     * `activities_added` types of goals. If
     * provided, everyone's goals will be returned.
     * @param {date} input['periodStart'] (optional) Start date of the period for which to find
     * goals. Date in format of YYYY-MM-DD. When `period.start`
     * is provided, `period.end` must be provided too.
     * @param {date} input['periodEnd'] (optional) End date of the period for which to find goals.
     * Date in format of YYYY-MM-DD.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static findGoals(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/goals/find';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            typeName: (input.typeName !== null) ? input.typeName : null,
            title: input.title,
            is_active: (input.isActive !== null) ? input.isActive : true,
            assigneeId: input.assigneeId,
            assigneeType: (input.assigneeType !== null) ? input.assigneeType : null,
            expectedOutcomeTarget: input.expectedOutcomeTarget,
            expectedOutcomeTrackingMetric: (input.expectedOutcomeTrackingMetric !== null) ? input.expectedOutcomeTrackingMetric : null,
            expectedOutcomeCurrencyId: input.expectedOutcomeCurrencyId,
            typeParamsPipelineId: input.typeParamsPipelineId,
            typeParamsStageId: input.typeParamsStageId,
            typeParamsActivityTypeId: input.typeParamsActivityTypeId,
            periodStart: _apiHelper.stringifyDateTime(input.periodStart, 'date'),
            periodEnd: _apiHelper.stringifyDateTime(input.periodEnd, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return GoalsController.findGoalsAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => GoalsController.findGoalsAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static findGoalsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Updates existing goal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {string} input['id'] ID of the goal to be updated.
     * @param {string} input['title'] (optional) Title of the goal.
     * @param {double} input['assignee'] (optional) Who is this goal assigned to. It requires the
     * following JSON structure: { "id": "1", "type": "person" }.
     * `type` can be either `person`, `company` or `team`. ID of
     * the assignee person, company or team.
     * @param {object} input['type'] (optional) Type of the goal. It requires the following JSON
     * structure: { "name": "deals_started", "params": {
     * "pipeline_id": 1 } }. Type can be one of: `deals_won`,
     * `deals_progressed`,`activities_completed`,`activities_added`
     * or `deals_started`. `params` can include `pipeline_id`,
     * `stage_id` or `activity_type_id`. `stage_id` is related to
     * only `deals_progressed` type of goals and `activity_type_id`
     * to `activities_completed` or `activities_added` types of goals.
     * To track goal in all pipelines set `pipeline_id` as `null`.
     * @param {object} input['expectedOutcome'] (optional) Expected outcome of the goal. Expected
     * outcome can be tracked either by `quantity` or by
     * `sum`. It requires the following JSON structure: {
     * "target": "50", "tracking_metric": "quantity" } or
     * { "target": "50", "tracking_metric": "sum",
     * "currency_id": 1 }. `currency_id` should only be
     * added to `sum` type of goals.
     * @param {object} input['duration'] (optional) Date when the goal starts and ends. It requires
     * the following JSON structure: { "start": "2019-01-01",
     * "end": "2022-12-31" }. Date in format of YYYY-MM-DD.
     * @param {IntervalEnum} input['interval'] (optional) Date when the goal starts and ends. It
     * requires the following JSON structure: { "start":
     * "2019-01-01", "end": "2022-12-31" }. Date in format
     * of YYYY-MM-DD.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateExistingGoal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/goals/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return GoalsController.updateExistingGoalAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => GoalsController.updateExistingGoalAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateExistingGoalAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            title: input.title,
            assignee: input.assignee,
            type: input.type,
            expected_outcome: input.expectedOutcome,
            duration: input.duration,
            interval: (input.interval !== null) ? input.interval : null,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Marks goal as deleted.
     *
     * @param {string} id ID of the goal to be deleted.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteExistingGoal(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/goals/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return GoalsController.deleteExistingGoalAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => GoalsController.deleteExistingGoalAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteExistingGoalAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Gets progress of a goal for specified period.
     *
     * @param  {array}  input    Array with all options for search
     * @param {string} input['id'] ID of the goal that the results are looked for.
     * @param {date} input['periodStart'] Start date of the period for which to find progress of a
     * goal. Date in format of YYYY-MM-DD.
     * @param {date} input['periodEnd'] End date of the period for which to find progress of a goal.
     * Date in format of YYYY-MM-DD.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getResultOfAGoal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/goals/{id}/results';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            periodStart: _apiHelper.stringifyDateTime(input.periodStart, 'date'),
            periodEnd: _apiHelper.stringifyDateTime(input.periodEnd, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return GoalsController.getResultOfAGoalAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => GoalsController.getResultOfAGoalAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getResultOfAGoalAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
}
module.exports = GoalsController;
